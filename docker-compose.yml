version: "3.8"
services:
#  spring-api:
#    container_name: spring-api
#    image: amazoncorretto:17.0.6-alpine
#    build:
#      context: ./spring-api
#      dockerfile: Dockerfile
#    env_file:
#      - .env
#    environment:
#      DB_HOSTNAME: postgres
#      DB_PORT: 5432
#      DB_NAME: ${APP_DB_NAME}
#      DB_USERNAME: ${APP_DB_USER}
#      DB_PASSWORD: ${APP_DB_PWD}
#    volumes:
#      - ./spring-api:/opt/app
#    restart: always
#    ports:
#      - "8080:8080"
#    expose:
#      - 8080
#      - 5005
#    depends_on:
#      postgres:
#        condition: service_healthy
  postgres:
    container_name: postgres
    image: postgres:15.4
    build:
      context: ./postgres
      dockerfile: Dockerfile
    volumes:
      - ./postgres/postgresql/data:/var/lib/postgresql/data
      - ./postgres/init:/docker-entrypoint-initdb.d
    env_file:
      - .env
    environment:
      POSTGRES_USER: ${POSTGRES_USER} # 선택 속성으로 POSTGRES_PASSWORD와 함께 사용되며, POSTGRES_USER명으로 superuser가 생성됨(작성하지 않을 경우 postgres 이름으로 superuser 생성)
      POSTGRES_PASSWORD: ${POSTGRES_PWD} # 필수 속성으로 postgreSQL의 superuser password(비어있거나 선언되지 않으면 안됨)
      POSTGRES_DB: ${APP_DB_NAME}
      APP_DB_USER: ${APP_DB_USER}
      APP_DB_PWD: ${APP_DB_PWD}
#    user: 컨테이너 유저 (설정하지 않으면 root)
    ports:
      - "5432:5432"
    expose:
      - "5432"
    healthcheck:
      #CHANGE 1: this command checks if the database is ready, right on the source db server
      test: pg_isready -d ${APP_DB_NAME}
      interval: 5s
      timeout: 5s
      retries: 5
#  next-front:
#    container_name: next-front
#    image: node:18-alpine
#    build:
#      context: ./next-front
#      dockerfile: Dockerfile
#    env_file:
#      - .env
#    environment:
#      ENV_VARIABLE: ${ENV_VARIABLE}
#      NEXT_PUBLIC_ENV_VARIABLE: ${NEXT_PUBLIC_ENV_VARIABLE}
#    volumes:
#      - ./next-front/src:/app/src
#      - ./next-front/public:/app/public
#    restart: always
#    ports:
#      - "3000:3000"
#    depends_on:
#      - spring-api
